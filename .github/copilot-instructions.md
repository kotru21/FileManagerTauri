# Copilot Instructions for FileManagerTauri

## Architecture Overview

This is a **Tauri 2.x desktop file manager** with React frontend following **Feature-Sliced Design (FSD)** architecture.

### Tech Stack

- **Frontend**: React 19, TypeScript 5.9, Zustand 5, TanStack Query 5, TanStack Virtual 3, Radix UI, Tailwind CSS 4
- **Backend**: Rust with Tauri 2.x, tauri-specta for type-safe bindings

### FSD Layer Structure (`src/`)

```
app/        → Entry point, providers, global styles
pages/      → Page components (FileBrowserPage)
widgets/    → Composite UI blocks (file-explorer, toolbar, sidebar)
features/   → Business features with model/store.ts (navigation, clipboard, search-content)
entities/   → Domain entities with api/queries.ts (file-entry, drive)
shared/     → Reusable code (api/tauri, ui/, lib/, config/)
```

## Key Patterns

### Tauri Commands & Type Safety

- All Rust commands are in `src-tauri/src/commands/*.rs`
- TypeScript bindings auto-generated in `src/shared/api/tauri/bindings.ts` by tauri-specta (DO NOT edit manually)
- Commands return `Result<T, E>` - use `unwrapResult()` from `@/shared/lib`:

```typescript
import { commands } from "@/shared/api/tauri";
import { unwrapResult } from "@/shared/lib";
const files = unwrapResult(await commands.readDirectory(path));
```

### State Management

- **Zustand stores** in `features/*/model/store.ts` - UI state (selection, navigation, clipboard)
- **TanStack Query** in `entities/*/api/queries.ts` - server state (file system data)
- Query keys pattern: `fileKeys.directory(path)`, `fileKeys.drives()`
- Constants in `src/shared/config/constants.ts`: `CACHE_TIME`, `VIRTUALIZATION`, `STORAGE_VERSIONS`

### UI Components

- Shared UI in `src/shared/ui/` - shadcn/ui style components (Button, Dialog, ContextMenu, etc.)
- Import via `@/shared/ui`: `import { Button, Dialog } from "@/shared/ui"`
- Use `cn()` from `@/shared/lib` for conditional classNames

### Security (Backend)

- Path validation required: `validate_path()` / `validate_paths()` in `file_ops.rs`
- Use iterative (not recursive) algorithms for directory operations to prevent stack overflow
- CSP configured in `src-tauri/tauri.conf.json`

## Commands

```bash
npm run tauri dev     # Development with hot reload
npm run tauri build   # Production build
npm run typecheck     # TypeScript check
npm run lint          # ESLint
cargo check           # Rust check (in src-tauri/)
```

## Code Style

- Language: Russian for UI text, English for code/comments
- Imports: Use `@/` alias (maps to `src/`)
- Exports: Each feature/entity has `index.ts` barrel file
- Memoization: Use `React.memo()` with custom comparator for virtualized list items (see `FileRow.tsx`)
- Zustand persist: Include `version` from `STORAGE_VERSIONS` for migration support

## Common Pitfalls

1. **bindings.ts**: Never edit - regenerated by tauri-specta
2. **Context menu**: Native WebView menu blocked globally in `app/index.tsx` - Radix handles custom menu
3. **Column resize**: Ensure all `columnWidths` fields are in memo comparator (`size`, `date`, `padding`)
4. **Result handling**: Always unwrap tauri command results, never access `.data` directly
